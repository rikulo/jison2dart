//@@LIBRARY@@
// Jison2dart generated parser

// ignore_for_file: directive_after_declaration
// ignore_for_file: return_of_invalid_type, argument_type_not_assignable, non_bool_condition
// ignore_for_file: non_bool_operand, variable_type_mismatch, switch_expression_not_assignable
// ignore_for_file: annotate_overrides, unused_local_variable, camel_case_types

import 'package:jison2dart/jison2dart.dart';

//@@CODE@@

class /*@@CLASS@@*/ extends /*@@EXTENDS@@*/ {
  final Map<dynamic, ParserSymbol> _symbols;
  final Map<int, ParserSymbol> _terminals;
  final Map<int, ParserProduction> _productions;
  final Map<int, ParserState> _table;
  final Map<int, ParserAction> _defaultActions;

  //const version = '0.4.17';

  static const int none = 0;
  static const int shift = 1;
  static const int reduce = 2;
  static const int accept = 3;

  //@@PARSER_MODULE_INJECTION@@

  //void trace() {
  //}

  //Setup Lexer
  //@@LEXER_INJECT@@

  factory /*@@CLASS@@*/() {
    //Setup Parser
    //@@PARSER_INJECT@@

    return /*@@CLASS@@*/._(symbols, terminals, table, defaultActions, productions);
  }

  /*@@CLASS@@*/._(this._symbols, this._terminals, this._table, this._defaultActions, this._productions);

  dynamic _parserPerformAction(ParserValue $thisS, ParserValue $yy, int $yystate, List $s, int $o) {
    //@@ParserPerformActionInjection@@
  }

  dynamic _lexerPerformAction(ParserValue yy, int $avoidingNameCollisions, String $YY_START) {
    //@@LexerPerformActionInjection@@
  }

  ParserSymbol _parserLex() {
    var token = _lexerLex(); // $end = 1

    if (token is num) {
      final symbol = _symbols[token];
      if (symbol != null) {
        return symbol;
      }
    }

    return _symbols['end']!;
  }

  @override
  Object parse(String $input) {
    var $firstAction = ParserAction(0, _table[0] as ParserState);
    var $firstCachedAction = ParserCachedAction($firstAction);
    var $stack = [$firstCachedAction];
    var $vstack = <dynamic>[null];
    var $yy;
    ParserValue? $_yy;
    var $recovering = 0;
    ParserSymbol? $symbol;
    var $action;
    String $errStr = '';
    var $preErrorSymbol;

    _setInput($input);

    while (true) {
      // retrieve state number from top of stack
      var $state = $stack.last.action!.state;
      // use default actions if available
      if ($state != null && _defaultActions[$state.index] != null) {
        $action = _defaultActions[$state.index];
      } else {
        $symbol ??= _parserLex();

        // read action for current state and first input
        if ($state != null && $state.actions[$symbol.index] != null) {
          //$action = _table[$state][$symbol];
          $action = $state.actions[$symbol.index];
        } else {
          $action = null;
        }
      }

      if ($action == null) {
        if ($recovering == 0) {
          // Report error
          var $expected = <String>[];
          _table[$state!.index]!.actions.forEach(($k, $v) {
            final terminal = _terminals[$k];
            if (terminal != null && $k > 2) {
                $expected.add(terminal.name);
            }
          });

          final terminal = _terminals[$symbol!.index];
          $errStr = getParserErrorMessage(yy.lineNo + 1,
            _input, matched, match, $expected,
            terminal != null ? terminal.name : 'NOTHING');
          throw ParserError($errStr,
              match, $state, $symbol, yy.lineNo, yy.loc, $expected);
        }
      }

      if ($state == null || $action == null) {
        break;
      }

      switch ($action.action as int) {
        case 1:
          //shift
          //shiftCount++;
          $stack.add( ParserCachedAction($action, $symbol));
          $vstack.add(yy.text);

          $symbol = null;
          if ($preErrorSymbol == null) { // normal execution/no error
            $yy = yy.clone();
            if ($recovering > 0) $recovering--;
          } else { // error just occurred, resume old look ahead f/ before error
            $symbol = $preErrorSymbol as ParserSymbol;
            $preErrorSymbol = null;
          }
          break;

        case 2:
          // reduce
          var $len = _productions[$action.state.index]!.len;
          // perform semantic action
          $_yy = ParserValue();
          $_yy.$ = $_yy.text = $len == 0 ? null : $vstack[$vstack.length - $len];// default to $S = $1
          // default location, uses first token for firsts, last for lasts
          // ignore: undefined_identifier

          yy.yystate = $action.state.index as int;
          var $r = _parserPerformAction($_yy, $yy, $action.state.index, $vstack, $vstack.length - 1);

          if ($r != null) {
            if ($r is ParserValue) return $r.$;
            return $r;
          }

          // pop off stack
          while ($len > 0) {
            $len--;
            $stack.removeLast();
            $vstack.removeLast();
          }

          $vstack.add($_yy.$);

          var $nextSymbol = _productions[$action.state.index]!.symbol;
          // goto new state = _table[STATE][NONTERMINAL]
          var $nextState = $stack.last.action!.state!;
          var $nextAction = $nextState.actions[$nextSymbol.index];

          $stack.add( ParserCachedAction($nextAction, $nextSymbol));

          yy.stack = $stack;
          yy.vstack = $vstack;
          break;

        case 3:
            // accept
            return true;
      }
    }

    return true;
  }

  /* Jison generated lexer */
  static final eof = ParserSymbol('Eof', 1);

  late ParserValue yy;
  var match = '',
    matched = '',
    done = false,
    _more = false;
  final _conditionStack = <String>[];
  late String _input;
  //late int _offset;

  void _setInput(String $input) {
    _input = $input;
    _more = done = false;
    matched = match = '';
    yy = ParserValue();
    _conditionStack..clear()..add('INITIAL');
    // ignore: undefined_identifier
    yy.loc = ParserLocation();
    //_offset = 0;
  }

  String input() {
    var ch = _input[0];
    yy.text += ch;
    yy.leng++;
    //_offset++;
    match += ch;
    matched += ch;
    RegExp regex = RegExp(r'(?:\r\n?|\n).*');
    Iterable<Match> lines = regex.allMatches(ch);
    if (lines.length > 0) {
      yy.lineNo++;
      yy.loc.lastLine++;
    } else {
      yy.loc.lastColumn++;
    }
    // ignore: undefined_identifier

    _input = _input.substring(1);
    return ch;
  }

  void unput(String $ch) {
    var len = $ch.length;
    var lines = $ch.split( RegExp(r'(?:\r\n?|\n)'));
    var linesCount = lines.length;

    _input = $ch + _input;
    yy.text = yy.text.substring(0, len - 1);
    //yylen -= $len;
    //_offset -= len;
    var oldLines = match.split( RegExp(r'(?:\r\n?|\n)'));
    var oldLinesCount = oldLines.length;
    match = match.substring(0, match.length - 1);
    matched = matched.substring(0, matched.length - 1);

    if ((linesCount - 1) > 0) yy.lineNo -= linesCount - 1;
    var r = yy.loc.range;
    var oldLinesLength = oldLines[oldLinesCount - linesCount].length;

    yy.loc = ParserLocation(
        yy.loc.firstLine,
        yy.lineNo,
        yy.loc.firstColumn,
        (lines.isEmpty ?
            (linesCount == oldLinesCount ? yy.loc.firstColumn : 0) + oldLinesLength:
            yy.loc.firstColumn - len)
    );
    // ignore: undefined_identifier
  }

  void more() {
    _more = true;
  }
  void less(int n) {
    this.unput(match.substring(n));
  }

  Object next() {
    if (done == true) {
      return eof;
    }

    if (_input.isEmpty) {
      done = true;
    }

    if (!_more) {
      yy.text = '';
      match = '';
    }

    var $rules = _currentRules();
    int? $index;
    Match? $match;
    var $token;
    for (var $i = 0, $j = $rules.length; $i < $j; $i++) {
      Match? $tempMatch;
      final rule = _rules[$rules[$i]];
      if (rule is InjectFunction) {
        $tempMatch = cast(rule(this, _input));
      } else {
        $tempMatch = (rule as RegExp).firstMatch(_input);
      }
      if ($tempMatch != null && (match.isEmpty == true || $tempMatch.group(0)!.length > $match!.group(0)!.length)) {
        $match = $tempMatch;
        $index = $i;
        // ignore: undefined_identifier
        //if (options['flex'] != true) {
          break;
        //}
      }
    }

    if ($match != null) {
      $token = _testMatch($match, $rules[$index!]);
      if ($token != false) {
        return $token;
      }
      // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
      return false;
    }

    if (_input.isEmpty) {
      return eof;
    } else {
      throw LexerError(
        getLexerErrorMessage(yy.lineNo + 1, _input, matched, match),
          yy.lineNo);
    }
  }

  /// test the lexed token: return FALSE when not a match, otherwise return token
  Object _testMatch(Match $match, int $ruleIndex) {
    int $matchCount = $match.group(0)!.length;
    var $lineCount = RegExp(r'(?:\r\n?|\n).*').firstMatch($match.group(0)!);
    var $line = $lineCount != null ? $lineCount.group(0)! : '';
    yy.lineNo += $lineCount != null ? $lineCount.groupCount : 0;

    yy.loc = ParserLocation(
      yy.loc.lastLine,
      yy.lineNo + 1,
      yy.loc.lastColumn,
      ($lineCount != null && $lineCount.groupCount > 0 ?
      $line.length -  RegExp(r'\r?\n?').firstMatch($line)!.groupCount :
      yy.loc.lastColumn + $matchCount
      )
    );

    yy.text += $match[0];
    match += $match[0]!;
//  matches = $match;
    matched += $match[0]!;

    yy.leng = yy.text.length as int;
    _more = false;
    _input = _input.substring($matchCount);
    var $nextCondition = _conditionStack.last;

    var $token = _lexerPerformAction(yy, $ruleIndex, $nextCondition);

    if (done == true && _input.isNotEmpty) {
      done = false;
    }

    if ($token != null) {
      return $token;
    } else {
      return false;
    }
  }

  Object _lexerLex() {
    var $r = next();

    while ((/*$r == null ||*/ $r == false) && !done) {
      $r = next();
    }

    return $r;
  }

  void begin(String $condition) {
    _conditionStack.add($condition);
  }

  String popState() {
    if (_conditionStack.length > 1) {
      return _conditionStack.removeLast();
    }
    return _conditionStack[0];
  }

  void pushState(String $condition) {
    begin($condition);
  }

  List<int> _currentRules() => _conditions[_conditionStack.last]!.rules;
}
