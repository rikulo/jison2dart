//@@LIBRARY@@
// Jison2dart generated parser

// ignore_for_file: directive_after_declaration
// ignore_for_file: return_of_invalid_type, argument_type_not_assignable, non_bool_condition
// ignore_for_file: non_bool_operand, variable_type_mismatch, switch_expression_not_assignable
// ignore_for_file: annotate_overrides, unused_local_variable, camel_case_types

import 'package:jison2dart/jison2dart.dart';

//@@CODE@@

class /*@@CLASS@@*/ extends /*@@EXTENDS@@*/ {
  Map symbols = {};
  Map terminals = {};
  Map productions = {};
  Map table = {};
  Map defaultActions = {};
  //String version = '0.4.17';
  //bool debug = false;
  static const int none = 0;
  static const int shift = 1;
  static const int reduce = 2;
  static const int accept = 3;
  late bool backtrack;
  //late InjectMatch getMatch;
  Map data = {};

  //@@OPTIONS_INJECT@@

  //@@PARSER_MODULE_INJECTION@@

  //void trace() {
  //}

  /*@@CLASS@@*/() {
    //Setup Parser
    //@@PARSER_INJECT@@

    //Setup Lexer
    //@@LEXER_INJECT@@
  }
  parserPerformAction($thisS, $yy, int $yystate, $s, $o) {
    //@@ParserPerformActionInjection@@
  }

  ParserSymbol parserLex() {
    var token = lexerLex(); // $end = 1

    if (token is num) {
      final symbol = symbols[token];
      if (symbol != null) {
        return symbol as ParserSymbol;
      }
    }

    return symbols['end'] as ParserSymbol;
  }

  Object parse(String $input) {
    if (table.isEmpty) {
      throw StateError('Empty');
    }
    eof = ParserSymbol('Eof', 1);
    var $firstAction = ParserAction(0, table[0] as ParserState);
    var $firstCachedAction = ParserCachedAction($firstAction);
    var $stack = [$firstCachedAction];
    var $vstack = <dynamic>[null];
    var $yy;
    ParserValue? $_yy;
    var $recovering = 0;
    ParserSymbol? $symbol;
    var $action;
    String $errStr = '';
    var $preErrorSymbol;

    setInput($input);

    while (true) {
     // retrieve state number from top of stack
     var $state = $stack[$stack.length - 1].action!.state;
      // use default actions if available
      if ($state != null && defaultActions[$state.index] != null) {
        $action = defaultActions[$state.index];
      } else {
        $symbol ??= parserLex();

        // read action for current state and first input
        if ($state != null && $state.actions[$symbol.index] != null) {
          //$action = table[$state][$symbol];
          $action = $state.actions[$symbol.index];
        } else {
          $action = null;
        }
      }

      if ($action == null) {
        if ($recovering == 0) {
          // Report error
          var $expected = <String>[];
          table[$state!.index].actions.forEach(($k, $v) {
            if (terminals[$k] != null && $k as num > 2) {
                $expected.add(terminals[$k].name as String);
            }
          });

          $errStr = getParserErrorMessage(yy.lineNo + 1,
            _input, matched, match as String, $expected,
            terminals[$symbol!.index] != null ? terminals[$symbol.index].name : 'NOTHING');
          throw ParserError($errStr,
              match as String, $state, $symbol, yy.lineNo, yy.loc, $expected);
        }
      }

      if ($state == null || $action == null) {
        break;
      }

      switch ($action.action as int) {
        case 1:
          //shift
          //shiftCount++;
          $stack.add( ParserCachedAction($action, $symbol));
          $vstack.add(yy.text);

          $symbol = null;
          if ($preErrorSymbol == null) { // normal execution/no error
            $yy = yy.clone();
            if ($recovering > 0) $recovering--;
          } else { // error just occurred, resume old look ahead f/ before error
            $symbol = $preErrorSymbol as ParserSymbol;
            $preErrorSymbol = null;
          }
          break;

        case 2:
          // reduce
          var $len = productions[$action.state.index].len;
          // perform semantic action
          $_yy = ParserValue();
          $_yy.$ = $_yy.text = $len == 0 ? null : $vstack[$vstack.length - ($len as int)];// default to $S = $1
          // default location, uses first token for firsts, last for lasts
          // ignore: undefined_identifier
          if (options['ranges'] == true) {
            //TODO: add ranges
            throw UnimplementedError('ranges');
          }

          yy.yystate = $action.state.index as int;
          var $r = parserPerformAction($_yy, $yy, $action.state.index, $vstack, $vstack.length - 1);

          if ($r != null) {
            if ($r is ParserValue) return $r.$;
            return $r;
          }

          // pop off stack
          while ($len as int > 0) {
            $len--;
            $stack.removeLast();
            $vstack.removeLast();
          }

          $vstack.add($_yy.$);

          var $nextSymbol = productions[$action.state.index].symbol;
          // goto new state = table[STATE][NONTERMINAL]
          var $nextState = $stack[$stack.length - 1].action!.state!;
          var $nextAction = $nextState.actions[$nextSymbol.index];

          $stack.add( ParserCachedAction($nextAction, $nextSymbol));

          yy.stack = $stack;
          yy.vstack = $vstack;
          break;

        case 3:
            // accept
            return true;
      }
    }

    return true;
  }

  /* Jison generated lexer */
  late ParserSymbol eof;
  late ParserValue yy;
  dynamic match = '';
  String matched = '';
  List<String> conditionStack = [];
  Map<int, dynamic> rules = {};
  Map<String, LexerConditions> conditions = {};
  bool done = false;
  late bool _more;
  late String _input;
  late int offset;
  dynamic ranges;
  bool flex = false;

  void setInput(String $input) {
    _input = $input;
    _more = this.backtrack = done = false;
    matched = match = '';
    yy = ParserValue();
    conditionStack = ['INITIAL'];
    // ignore: undefined_identifier
    if (options['ranges'] == true) {
      var loc = yy.loc = ParserLocation();
      loc.setRange( ParserRange(0, 0));
    } else {
      yy.loc = ParserLocation();
    }
    offset = 0;
  }

  String input() {
    var ch = _input[0];
    yy.text += ch;
    yy.leng++;
    offset++;
    match += ch;
    matched += ch;
    RegExp regex = RegExp(r'(?:\r\n?|\n).*');
    Iterable<Match> lines = regex.allMatches(ch);
    if (lines.length > 0) {
      yy.lineNo++;
      yy.loc.lastLine++;
    } else {
      yy.loc.lastColumn++;
    }
    // ignore: undefined_identifier
    if (options['ranges'] == true) {
      yy.loc.range.y++;
    }

    _input = _input.substring(1);
    return ch;
  }

  void unput(String $ch) {
    var len = $ch.length;
    var lines = $ch.split( RegExp(r'(?:\r\n?|\n)'));
    var linesCount = lines.length;

    _input = $ch + _input;
    yy.text = yy.text.substring(0, len - 1);
    //yylen -= $len;
    offset -= len;
    var oldLines = match.split( RegExp(r'(?:\r\n?|\n)'));
    var oldLinesCount = oldLines.length;
    match = match.substring(0, match.length - 1);
    matched = matched.substring(0, matched.length - 1);

    if ((linesCount - 1) > 0) yy.lineNo -= linesCount - 1;
    var r = yy.loc.range;
    var oldLinesLength = (oldLines[oldLinesCount - linesCount]) != null ?
      oldLines[oldLinesCount - linesCount].length : 0;

    yy.loc = ParserLocation(
        yy.loc.firstLine,
        yy.lineNo,
        yy.loc.firstColumn,
        (lines.isEmpty ?
            (linesCount == oldLinesCount ? yy.loc.firstColumn : 0) + (oldLinesLength as int):
            yy.loc.firstColumn - len)
    );
    // ignore: undefined_identifier
    if (options['ranges'] == true) {
      yy.loc.range = ParserRange(r.x, r.x + yy.leng - len);
    }
  }

  void more() {
    _more = true;
  }

  void reject() {
    // ignore: undefined_identifier
    if (options['backtrack_lexer'] == true) {
      this.backtrack = true;
    } else {
      throw LexerError(
        getLexerErrorMessage(yy.lineNo + 1, _input, matched, match as String, reject: true),
        yy.lineNo);
    }
  }

  void less(int n) {
    this.unput((this.match as String).substring(n));
  }

  Object next() {
    if (done == true) {
      return eof;
    }

    if (_input.isEmpty) {
      done = true;
    }

    if (!_more) {
      yy.text = '';
      match = '';
    }

    var $rules = currentRules();
    int? $index;
    Match? $match;
    var $token;
    for (var $i = 0, $j = $rules.length as int; $i < $j; $i++) {
      Match? $tempMatch;
      final rule = rules[$rules[$i]];
      if (rule is InjectFunction) {
        $tempMatch = cast(rule(this, _input));
      } else {
        $tempMatch = (rule as RegExp).firstMatch(_input);
      }
      if ($tempMatch != null && (match.isEmpty == true || $tempMatch.group(0)!.length > $match!.group(0)!.length)) {
        $match = $tempMatch;
        $index = $i;
        // ignore: undefined_identifier
        if (options['backtrack_lexer'] == true) {
          $token = testMatch($tempMatch, $rules[$i] as int);
          if ($token != false) {
            return $token;
          } else if (this.backtrack) {
            $match = null;
            continue; // rule action called reject() implying a rule MISmatch.
          } else {
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
          }
        // ignore: undefined_identifier
        } else if (options['flex'] != true) {
          break;
        }
      }
    }

    if ($match != null) {
      $token = testMatch($match, $rules[$index] as int);
      if ($token != false) {
        return $token;
      }
      // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
      return false;
    }

    if (_input.isEmpty) {
      return eof;
    } else {
      throw LexerError(
        getLexerErrorMessage(yy.lineNo + 1, _input, matched, match as String),
          yy.lineNo);
    }
  }

  // test the lexed token: return FALSE when not a match, otherwise return token
  testMatch(Match $match, int $ruleIndex) {
    late Map<String, dynamic> backup;
    // ignore: undefined_identifier
    if (options['backtrack_lexer'] == true) {
      // save context
      backup = {
        'yy': this.yy.clone(),
        'match': this.match,
        'matched': this.matched,
        'offset': this.offset,
        '_more': this._more,
        '_input': this._input,
        'conditionStack': this.conditionStack.toList(),
        'done': this.done
      };
    }
    int $matchCount = $match.group(0)!.length;
    var $lineCount = RegExp(r'(?:\r\n?|\n).*').firstMatch($match.group(0)!);
    var $line = $lineCount != null ? $lineCount.group(0)! : '';
    yy.lineNo += $lineCount != null ? $lineCount.groupCount : 0;

    yy.loc = ParserLocation(
      yy.loc.lastLine,
      yy.lineNo + 1,
      yy.loc.lastColumn,
      ($lineCount != null && $lineCount.groupCount > 0 ?
      $line.length -  RegExp(r'\r?\n?').firstMatch($line)!.groupCount :
      yy.loc.lastColumn + $matchCount
      )
    );


    yy.text += $match[0];
    match += $match[0];
//  matches = $match;
    matched += $match[0]!;

    yy.leng = yy.text.length as int;
    if (ranges != null) {
      yy.loc.range = ParserRange(offset, offset += yy.leng);
    }
    _more = false;
    backtrack = false;
    _input = _input.substring($matchCount);
    var $nextCondition = conditionStack[conditionStack.length - 1];

    var $token = lexerPerformAction(yy, $ruleIndex, $nextCondition);

    if (done == true && _input.isNotEmpty) {
      done = false;
    }
    try {
      if ($token != null) {
        return $token;
      } else if (this.backtrack) {
        backup.forEach((k, v) {
          switch (k) {
            case 'yy':
              this.yy = v as ParserValue;
              break;
            case 'match':
              this.match = v;
              break;
            case 'matched':
              this.matched = v as String;
              break;
            case 'offset':
              this.offset = v as int;
              break;
            case '_more':
              this._more = v as bool;
              break;
            case '_input':
              this._input = v as String;
              break;
            case 'conditionStack':
              this.conditionStack = v as List;
              break;
            case 'done':
              this.done = v as bool;
              break;
            default:
              throw UnsupportedError('Unknown $k');
          }
        });
        return false; // rule action called reject() implying the next rule should be tested instead.
      } else {
        return false;
      }
    } finally { // extra feature
      if (data['backtrack'] == true) {
        backup.forEach((k, v) {
          switch (k) {
            case 'yy':
              this.yy = v as ParserValue;
              break;
            case 'match':
              this.match = v;
              break;
            case 'matched':
              this.matched = v as String;
              break;
            case 'offset':
              this.offset = v as int;
              break;
            case '_more':
              this._more = v as bool;
              break;
            case '_input':
              this._input = v as String;
              break;
            case 'conditionStack':
              this.conditionStack = v as List;
              break;
            case 'done':
              this.done = v as bool;
              break;
            default:
              throw UnsupportedError('Unknown $k');
          }
        });
        popState();
        data['backtrack'] = false;
      }
    }
  }

  Object lexerLex() {
    var $r = next();

    while (($r == null || $r == false) && !done) {
      $r = next();
    }

    return $r;
  }

  void begin($condition) {
    conditionStack.add($condition);
  }

  String popState() {
    var n = conditionStack.length - 1;
    if (n > 0) {
      return conditionStack.removeLast();
    }
    return conditionStack[0];
  }

  void pushState($condition) {
    this.begin($condition);
  }

  List<int> currentRules() {
    if (this.conditionStack.length > 0 && this.conditionStack[this.conditionStack.length - 1] != null) {
      return this.conditions[this.conditionStack[this.conditionStack.length - 1]]!.rules;
    } else {
      return this.conditions["INITIAL"]!.rules;
    }
  }

  // ignore: avoid_init_to_null
  dynamic lexerPerformAction(yy, int $avoidingNameCollisions, [String? $YY_START = null]) {
    //@@LexerPerformActionInjection@@
  }
}
